/*
 * Contrataciones.c
 *
 *  Created on: 12 oct. 2021
 *      Author: usuario
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdio_ext.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>

#include "Pantalla.h"
#include "Pedir.h"
#include "Contrataciones.h"
#include "Menu.h"

#define TAMANO_ARRAY 10
#define OCUPADO 0
#define LIBRE -1
#define MINIMO 1
#define MAXIMO 11
#define INTENTOS 3
#define MES 30

/*
 typedef struct{
	int cuit; //0 LCD 1 LED
	int cantidadDias;
	int idContratacion;
	char nombreArchivo[128];
	int id;
	int flagEmptyC; //0 ocupada 1 vacia
}Contrataciones;
 */

static int dameUnIdNuevo2(void);
/**
 * \brief inicializa todas las posiciones del array como Libres pone la bander isEmpty en -1
 * \param  *plistEmployee recibo array por referencia, len tamaño del array
 * \return Retorna 0 si todo bien y -1 si no logro inicializar el array
 */
int iniciarEarrayC(Contrataciones *plistContrato,int len)
{
	int estado=-1;
	   if (plistContrato!=NULL && len>0)
	   {
		  for (int j = 0;  j<len; j++)
		   {
			  plistContrato[j].flagEmptyC=LIBRE;
			  estado=0;
		   }
	   }
	   return estado;
}
//=============================================================================
/**
* \brief da de alta un display en el array de Display
* \param recibe un array de estructura, el largo
* \return Retorna -1 todo mal 0 todo bien
*/
int altaContrato(Contrataciones pContrato[],int len)
{
	int retorno=-1;
	int libre;
	if(pContrato!=NULL && len>0)
	{
		libre=buscarLugarLibreContrato(pContrato, TAMANO_ARRAY);
		if(buscarLugarLibreContrato(pContrato, TAMANO_ARRAY)>=0)
			{
				printf("\nEl primer lugar libre es %d\n",libre);
				if(disp_loadContrato(&pContrato[libre], TAMANO_ARRAY)==0)
				{
					puts("Se ha completado la carga");
				}else
				{
					puts("No se ha completado la carga");
				}
			}else
				{
					puts("No hay espacio libre en el array");
				}
	}
	retorno=0;
return retorno;
}
//=============================================================================
/**
* \brief Dar de alta un display
* \param recibe un estructura por puntero y el largo
* \return Retorna 0 si se logor carga  y -1  si no
*/
int disp_loadContrato(Contrataciones *pContrato, int len)
{
	int estado=-1;
	char bufferCuit[32];
	char bufferNameArch[128];
	int cantidadDias;
	int idPantalla;
	   if(pContrato!=NULL && len>0)
	   {
		   if(pedirText(bufferCuit,  sizeof(pContrato->cuit), "Ingrese CUIT-Sin espacios", "Ingrese tipo valido", INTENTOS)==0)
		    {
			     if(pedirInt(&cantidadDias, "Dias de la publicacion", "Ingrese menos de 30", MINIMO, MES,INTENTOS)==0)
			     {
			    	 if(pedirText(bufferNameArch, sizeof(pContrato->nombreArchivo), "ingrese el nombre del archivo", "Nombre invalido",INTENTOS)==0)
			    		 {
			    		 imprimirDisplayCargadoC(pContrato, TAMANO_ARRAY);
			    		 if(pedirInt(&idPantalla, "Ingrese Pantalla a contratatr", "Ingrese pantala valida", MINIMO, len, INTENTOS ))
			    		 {
			    			 strncpy(pContrato->cuit, bufferCuit,sizeof(pContrato->cuit));
			    			 pContrato->cantidadDias=cantidadDias;
			    			 strncpy(pContrato->nombreArchivo, bufferNameArch,sizeof(pContrato->nombreArchivo));
			    			 pContrato->idContratacion=dameUnIdNuevo2();
			    			 pContrato->flagEmptyC=OCUPADO;
			    			 pContrato->id=idPantalla;
			    			 estado=OCUPADO;
			    		 }

			    	 }
			     }
		   }
	   }
	   return estado;
}
//===========================================================================
/**
 * \brief busca cantidad de posiciones ocupadas en el array
* \param *plistEmployee recibo array por referencia, len tamaño del array
* \return Retorna cantidad de lugares o -1 si no encuentra ninguno lugar ocupados
 */
int largoArrayC(Contrataciones *plistContra,int len)
{
	int retorno=-1;
	int contBusy=0;
	if(plistContra!=NULL && len>0)
	{
		for (int i=0;i<len;++i)
		{
			if(plistContra[i].flagEmptyC==OCUPADO)
			{
				contBusy++;
			}
		}
		if(contBusy>0)
		{
			retorno=contBusy;
		}
	}
	return retorno;
}
//===================================================================================
//=============================================================================
/**
* \brief busca e Imprime el array Display cargado con datos flag busy
* \param recibe un estructura por puntero y el largo
* \return Retorna 0 si se logor carga  y -1  si no
*/
int imprimirDisplayCargadoC(Contrataciones pContra[], int len)
{
	int estado=-1;
	int contadordeCargados=0;
	printf("\nFlagEmpt\t Id\t Type\t Price\t Name\t Address\t\n");
	if (pContra!=NULL && len>0)
	{
		for (int i= 0;  i< len; i++)
		{
			if(pContra[i].flagEmptyC==OCUPADO)
			{
				printf("\n\t%d \t%d \t%d \t%s \t%s \t%d\n",
				pContra[i].flagEmptyC,pContra[i].id,pContra[i].cantidadDias,
				pContra[i].cuit,pContra[i].nombreArchivo,pContra[i].idContratacion);
				contadordeCargados++;
			}
		}
		if(contadordeCargados==0)
			{
				puts("NO HAY DIPLAYS CARGADOS");
			}
	}
	estado=0;
	return estado;
}


//==========================================================================================
/*
 typedef struct{
	int cuit; //0 LCD 1 LED
	int cantidadDias;
	int idContratacion;
	char nombreArchivo[128];
	int id;
	int flagEmptyC; //0 ocupada 1 vacia
}Contrataciones;
 */
//=============================================================================
/**
* \brief busca el primer index del array con flag emty
* \param recibe un estructura por puntero y el largo
* \return Retorna lugar el primer lugar libre de la lista o -1 si no encuentra ninguno libre
*/
int buscarLugarLibreContrato(Contrataciones *pContrato, int len)
{
	int retorno=-1;
	if(pContrato!=NULL && len>0)
	{
		for (int i=0;i<len;++i)
		{
			if(pContrato[i].flagEmptyC==LIBRE)
			{
				retorno=i;
				break;
			}
		}
	}
	return retorno;
}
//=============================================================================
/**
  * \brief me da un id consecutivo y no repetido memorizando el ultimolvalor
  * \param void
  * \return Retorna 0 si todo bien  y -1 si no numero de id
  */
static int dameUnIdNuevo2(void)
{
	static int contador=0; //varable Global y solo de esta funcio y no olvida el valor mientra corre
	contador++;
	return contador;
}
//================================================================================
